function handleEachNode(data, contextStack = new Map(), eachNode, mountNode, refreshMode = false, startAfterExisting = 0) {

        function toFullKey(key) {
            const firstOfSegment = key.split('.')[0]

            if (contextStack.has(firstOfSegment) && contextStack.get(firstOfSegment).of) {
                return `${contextStack.get(firstOfSegment).full}.${ofAttribute.split('.')[1]}`
            }

            return key
        }

        const ofAttribute = eachNode.getAttribute('of')
        const fullOfAttribute = toFullKey(ofAttribute)

        const asAttribute = eachNode.getAttribute('as')

        if (!refreshMode) {
            nodeHoldersByKeys.appendToKey(fullOfAttribute, { node: eachNode, mountNode: mountNode, updateHandler: 'setArray', contextStack: new Map(contextStack) })
        }

        const list = resolve(fullOfAttribute, data)

        if (list.constructor.name !== 'Array') {
            throw new Error('each-of must be an Array')
        }

        const startIndex = refreshMode ? list.length - startAfterExisting : 0

        for (let index = startIndex ; index < list.length ; index++) {
            const listElement = list[index]
            const childContextStack = new Map(contextStack)
            childContextStack.set(asAttribute, { data: listElement, of: ofAttribute, index: index, full: `${fullOfAttribute}.${index}` })
            walk(data, childContextStack, eachNode.childNodes, mountNode)
        }
    }